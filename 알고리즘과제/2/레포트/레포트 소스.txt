1. 개요
2. 설계
3. 알고리즘 구현
4. 요구사항





1. 개요
해당 과제에 있어서 강의교안내에서 고르라는 소팅 알고리즘 두가지는 주로 최악의 경우의 수를 보여주는 버블소팅과, 효율성이 높기로 유명한 힙 소팅을 이용했다. 이때 버블정렬은 flag를 이용해서 비교 횟수를 줄일수 있게 해서 성능을 약간 향상시켰다. 

버블정렬은 1,2  2,3 3,4 이렇게 비교하고 마지막에 n-1, n 번째를 정렬한 뒤에 다시 1,2 2,3 n-2,n-1 이런식으로 정렬해서 최대 n(n-1)/2 q번 정렬한다. 여기서 효율성을 높였다는 것은 정렬을 하는동안 1회전을 마치거나 2회전을 마친 상태일때 이미 정렬이 완료된 경우도 있다. 이때 정렬이 완료된 경우 남은 과정을 수행하지 않고 출력하도록 flag를 이용했다. 예를 들어 한회전이 모두 끝났는데 flag값을 조사했을때 0이면 회전중 교환이 한번도 일어나지 않았다는 뜻으로 정렬이 이미 완료 되었다는 이야기이다. 

힙소팅은 삽입하는 원소들을 모두 heap이라는 데이터 구조로 변형을 시켜야 한다. 힙이라는 것은 완전 이진트리의 형태를 듸면서 부모의 값은 항상 자식의 값보다 크거나 작아야 한다는 규칙이 있다.  힙 소팅은 원소들을 전부 힙에 삽입한다. 그리고 힙의 루트에 있는 값들 중 (여기서는) 최댓값을 출력하고 힙에서 제거한다. 그리고 나머지 원소들을 다시 heap이라는 데이터 구조로 변형을 하고 이를 반복한다. 기본적으로 부모와 자식간의 이동을 통해서 log2(n)단위로 빠르게 자신의 위치를 찾아갈수 있다. 안정적으로  O(nlogn) 정렬의 성능을 발휘하는 장점이 있다.

2. 설계
레포트2에서 직관적으로 물어보는 것은 데이터베이스를 구현할 능력이 되는지와 소팅을 할수 있는지에 대해 물어보고 있다. 
문제에서 말하는 프로그램을 통해 제공할 서비스는 멜론 차트의 노래들의, 순위, 제목, 가수, 앨범명 이렇게 했다. 
해당 데이터 베이스를 구현하는 방법으로는 우선 텍스트에 \t을 기준으로 
순위	제목	가수	앨범
이렇게 적어놓았고 이를 텍스트파일의 내용을 한줄씩 받아오는 형태로 구조체를 통해 구현했다. 
구조체를 통해 구현되어있음으로, 한가지 내용을 바꿀때 전체 데이터가 바뀌는 것을 확인 할수 있게 구현을 했다. 
소팅알고리즘은 거의 가장 최악이라고 불리는 버블 정렬과, 효율성이 높은 것으로 유명한 힙정렬을 통해 구현했다. 


3.
함수는 크게 버블소팅을 하는 함수와 힙소팅을 하는 함수 두가지 유형이 필요하다. 
하지만 구조체의 각각 요소에 따라 함수를 따로 만들어야 해서 그 갯수가 많아보이는 것이지 실제로 만든 함수의 유형을 2가지 밖에 없다. 

우선 music이라는 구조체를 선언해서 그 안에 rank, name, singer album이라는 인자드롤 채워 넣는다. 

bubble소팅에 대해 보도록 하자
flag는 만이 하나 교환이 일어나지 않아서 버블소팅이 다 되었음을 조기에 확인 할수 있는 경우를 대비해서 달아 놓은 것이다. 
우선 i는 1부터 시작하고 j는 0부터 시작한다. 
버블소팅은 1,2 2,3 식으로 교환한다. 만약 각각  j, j+1 의순서가 틀렸다면 이를 교환해준다. 이를 계속 n-1까지 반복해준다.
이때 만약에 flag가 0으로 나와서 이미 정렬된 상태라는 것이 확인이 된다면 바로 소팅을 그만한다. 

힙 소팅은  크게 두가지 과정으로 나뉜다. 첫번재는 힙을 만드는 것과, 소팅을 하는 과정 크가 두가지로 나뉜다. 

1부터 시작해서 전체 원소에 대해 힙을 만든다. 우선 i를 자식으로 정의한다. 부모는 당연히 자식 보다 힙구조에서 위에있는 값이라서 (child-1)/2를 해준다.
부모의 값보다 자식의 값이 더 크다면 위치를 바꿔준다.  여기서 t는 구조체다. 
다시 자식이 부모로 이동해서 이를 반복적으로 수행한다. 재귀적으로 do while문을 이용하면 짧은 코드를 이용해서 힙 구조를 만들수 있다. 

기본적으로 처음 루트노드와 가장 마지막에 있는 원소를 바꿔주고(0번째와 i번째를 바궈준다) 
자연스럽게 오름차순 정렬이 이뤄진다. . 
parent는 0으로 잡고 child는 1로 잡아서 child는 루트의 자식이 되고 자식중 더 큰 값을 찾는다. c c+1을 비교하고 c는 i-1 보다 크게 되면 범위를 벗어난다. 
이때 재귀적으로 다시 힙을 구성해 준다. 
이때 함수 처음에 힙구성을 한것과 방법론적으로 다른데, 처음에는 자식에서 부모로 올라가는 형식이고, 이번에는 맨처음 부모에서 자식으로 서로 비교하면서 힙구조를 다시 만들어 가는 구조이다. 

main함수로 이동하자. 
메인함수에서는 strtok을 이용해서 txt로 제시한 한줄을 어떻게 나누느냐가 가장 중요하게 제시 될것이다. 
structcnt는 데이터베이스 구축중 각각 서로 다른 구조체의 요소에 저장을 하기 위한 중간자이다. 
insertcnt는 정체 자료의 갯수를 의미한다. 
iptr은 ptr로 받은 주소값에서 출력하는 값이 정수로 바꿀대 쓸 숫자이다. 
우선 ifstream으로 txt파일을 불러낸다. 50개를 넣는다고 했으니 50까지 반복문을 잡고
getline을 해준다. 
이때 getline을 strcpy를 통해서 wholearr이라는 char array에 모두 넣는다. 그리고 이 whoearr을 스트링토큰을 통해서 문자열을 자른다. 이 txt파일에는 \t 을 기준으로 자르기로 했고 그 포인터 값을 반환한다. 
rank 같은 경우에는 stoi를 이용해서 이것을 정수로 만들어서 rank에 저장해 준다. 
나머지는 while 문을 통해 자른 문자열이 나오지 않을때 까지 반복하고 structcnt를 통해서 각각 name singer album에 적절하게 저장할수 있도록 한다. 


menu룰 보면
insert
sort
erase
print
end
가 존재한다. 
insert는 각각의 구조체의 요소에 하나씩 넣어주면 된다. 
소팅 같은 경우에는 위에서 제시해준 함수를 각각 원하는 요소에 넣어주면 된다. 각각 해당할수 있도록 중첩 if문을 구성해줬다. 
erase같은 경우에는 순위를 기준으로 삭제를 하기로 했다.  
우선 순위를 전체로 검색해서 해당하는 순위가 있나 확인을 하고 그에 해당하는 music[i]의 i값을 구한다. 
그리고 그 i를 삭제함에있어서 i = i+1을 반복하고 insertcnt를 하나 줄여주는 방식으로 간단히 삭제를 구현했다. 
print는 있는 구조체들을 모두 나열하는 방식으로 했다.. 

캡쳐에 앞서서 powershell에서 구동을 하면서 코딩 할때는 할때는 txt를 ANSI로 인코딩 했고 시간 측정 비교를 위해 우분투에서 구동할때는 utf-8로 txt를 인코딩 했다.