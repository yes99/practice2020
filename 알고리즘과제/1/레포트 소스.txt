


1
보이어-무어 알고리즘과 KMP 알고리즘의 목적과 유사하다. 불필요한 것은 건너뛰고, 검색을 빠르게 하자는 것이 주 목표이다.
보이어-무어 알고리즘은 보통 상황에서 문자열은 앞부분보다는 뒷부분에서 불일치가 일어날 확률이 높다는 성질을 활용해서 그래서 오른쪽 끝부터 비교하게 된다.

보이어 무어 , 올드 아이디어 이용했다. 다른데서는 good suffix라고도 한다. 이는 kmp 알고리즘에 bm의 char jump를 적절히 차용한 것이다. 매치 점프라는 배열을 만들어서 그 패턴에 대해서 미스매치가 일어낫을때 해당하는 위치로 이동시킨다. 
해당 매치점프 배열은 작성. 일단 보이어 무어는 오른쪽 부터 시작하여 비교하게 된다. 
이때 오른쪽에서 시작하여 처음으로 일치가 되지 않는 문자의 순서를 가지게 된다. 불일치가 일어났어도 일정 기간은 점프가 가능하다는 것을 고려해줘야 한다. 일치하는 부분 문자열이 없으면 한꺼번에 점프할수 있다. 일치하는 문자열이 있으면 그 해당 일치하는 파트가 올때까지 점프해준다.

보이어무어를 구성하기 위하여 매치 점프 배열을 만들때 오른쪽부터 주어진 숫자만큼의 배열이 또 존재하나(r) 찾아보고 각각  그 이전 즉 P(k)와 P(r-1)가 일치하는 지를 확인한다. 
만약에 일치하지 않는다면 m-(r-1)을 해준다. 패턴안에 있는 r 의 위치부터 특정 숫자의 값이 k+1부터 m 까지 같다는 것이라서 m = r-1 구간까지 이동해 줘야 함으로 m - (r-1)이 성립한다.  
일치한다면 m-k+m-q를 해준다.  k의 위치에서 이미 성립하지 않는 다는 것을 아는데 일치한 위치까지 옮겨준다고 해도 의미가 없기 때문에 kmp에서 했던 것 처럼 suffix값이 같은 만큼 이동을 하게 됨으로 m-k+m-q를 해주면 된다.
만일 아무것도 존재하지 않는다면 위와 같은 이유로 m-k+m-q이다.
그래서 주로 매치점프 배열은 왼쪽으로 갈수록 더 큰숫자를 보이게 된다. 그런데 맞는말인게 거의다 일치했고 앞부분에서 틀렸다는 말이기 때문에 그만큼 더 긴 점프를 해줘도 된다는 의미이다. 

kmp는 오토마타를 이용한 매칭에서는 문자열을 왼쪽에서 오른쪽으로 차례로 훑는다. 그리고 어느 지점에서 매칭이 성공하지 못했어도 그 지점을 기준으로 마지막 몇개의 부분 문자열이 찾으려는 패턴 문자열의 앞부분과 일치한다면 그 정보를 이용한다. 
fail 차트를 잘 만드는 것이 중요하다. 우선 1부터 시작한다 가정하면 fail[1]은 무조건 0이고 fail[2]는 1이라고 설정을 하고 들어간다. 
fail[k-1]이 계산 되어있다고 가정을 한다(당연하다, 왼쪽에서 오른족으로 차례로 계산하게 되어잇으니)
P(k-1) = P(fail(k-1)) 일 경우에는 fail[k] = fail[k-1]+1이고
P(k-1) != P(fail(k-1))일 경우에는 fail[fail[k-1]] =r' 이라 하고 P(k-1) = P(r') 과 같을때 까지 이를 반복하고 같으면 fail[k] = r'+1

2
기본적으로 수업시간에 배운내용을 그대로 따라간다고 생각하고 코딩을 했다.
kmp는 기본적으로 fail 배열을 만들고 그에 따라 슬라이딩을 한다는 구상을 가지고 코딩을 했다. 
bm보다 간단하게 구상이 되고 짜여졌다. 개인적으로 fail배열을 1부터 보는 것이 편해서 이를 따라서 우선 string으로 선언한 pattern을 char 로 선언한 배열로 모두 옮기고 fail을 만들었다. 
그리고 만들어진 fail 배열을 기반으로 불일치 하는 경우가 나왔을대는 해당 차트가 가리키는 주소로 슬라이딩을 한다는 식으로 kmp를 이동시켰다. 만약 모두 일치 되었을 경우에는 가장 마지막에 있는 문자에서 미스매치가 되었다는 전제로 슬라이딩을 시켰다. 

bm은 고려할것이 많다. 기본적으로 matchjump 배열을 만들때 계산식이  m-(r-1) 과 m-k+m-q 이다. 이때 r의 위치를 찾는 것이랑 몇개의 접두 접미가 같은지 q를 계산하는 함수를 따로 따로 다 만들어 주어야 한다. suffix matchjump mjarray move이런식으로 4개의 단계로 구성을 햇다. 매치 점프를 모두다 만들었으면 미스매치가 일어난 부분까지는 같다는 전제를 가지고 해당 배열이 가리키는 곳으로 슬라이딩을 하는식으로 이동한다. 

3.
기본적으로 함수를 많이 이용했다. 이곳 구현 파트에서는 각각의 함수들이 어떤 역할을 하고 어떤식으로 만들어졌는지를 설명을 할 것이다. 

1. txttostring(code배열안에 저장할 txt에서 추출한 모든 문자열, 우리가 넣을 txt파일 갯수   )
이미 input0.txt (0이라는 숫자가 1 2 3 이런식으 텍스트가 더 있음) 이미 존재하는 input.txt 이라는 이름으로 존재하는 텍스트 파일을 자동적으로 입력시켜 주는 것이다. 
string으로 temp - 임시로 사용, text- 쓸 텍스트의 이름을 선언, num- 몇번째인지 순서  을 입력해준다. 
반복문에서는 0부터 몇개를 입력할지를 입력한다. 
첫 세줄은 input + 숫자 + .txt 를 append 를 통해 만드는 과정이고 이를 text 스트링에 저장을 하고 차례대로 ifstream에다가 입력을 한다. 

while문에는 getline을 통해서 줄단위로 받는 문자열이 존재할때 까지 그것을 code[i]라는 string배열중 하나에 계속 이어 붙인다는 이야기이다. 

2. inputtext(code배열안에 저장할 txt에서 추출한 모든 문자열, 우리가 넣을 txt파일 갯수)
위 보다 조금더 심플하다, 왜냐하면 cin>> 으로 내가 원하는 텍스트 파일을 직접 입력 받기 때문이다. 
나머지 문자열을 받아서 저장하는 원리는 위의 함수와 같다. 

3.flowchart( 비교하려고 하는 패턴, 저장할 fail배열)
우선 Parray라는 배열은 string으로 선언한 패턴을 1부터 저장해주기 위해 준비했다. 
fail[1] [2]는 디폴트 값으로 0과 1로 선언을 해준다. 
check와 x는 차후 while반복문에서 쓰이게 될것이다. 

첫번째 반복문에서느 ㄴ1부터 시작하고 싶어서 string에 있는 모든 값들을 [1]부터 입력시키는 것이다. 
두번재 반복문은 잘 입력되었나 디버깅 용이다. 

그 뒤에 나오는 for 반복문에서는 3부터 pattern길이까지 fail배열에 차례 대로 입력을 할것이다. 
첫번재 조건문에서는 P[i-1] = P[fail[i-1]]과 같을 경우에는 fail[i]값이 +1 증가한다는 것을 보여준다. 

그 뒤에는 우선 check 에 i를 저장해 준다. i를 직접적으로 건들게 되면 큰 반복문에 문제가 생기기 때문에 check에서 건드려 줄 것이다. 
만약 fail[fail[i-1]] =0 일경우에는 단순히 1이라고 선언해주면 된다.
그것이 아닐 경우에는 fail문을 반복적으로 돌려야 한다. 
이때 fail[fail[i-1]] = fail[x] 라고 무한으로 돌릴수 있게 하기 위해서 x = fail[check-1] 이라고 선언을 하고 do while문을 이용해서 이를 무한으로 반복한다. 
만약에 이를 반복하는 과정에서 0이 나온다면 그 해당 fail 배열은 1이라고 하며 ㄴ되는것이고 만약 같은 값이 나온다면 else if 문에 나온 것 처럼 parray[i-1] 에 +1 값을 해주면 된다. 


4.kmpmove (비교할 text, 비교할 pattern , 위에서 구한 fail 차트)
반복문을 선언해서 0부터 text끝까지 비교하도록 한다. 그 밑에 반복문에서는 0부터 pattern의 길이까지 진행을 하는 반복문을 만든다.
이때 text[i+j]와 pattern[j]가 모두 같은지 확인을 한다. 이를cnt를 통해서 하나씩 확인해준다. 
cnt가 패턴의 길이와 같아서 모두 일치하거나 아니면 cnt가 특정 갯수일때 미스매치가 일어나서 break해서 반복문을 탈출하는 경우가 생길 것이다.

여기서 중요한것은 해당 fail 배열에서 나오는 숫자를 와 관련해서 어떻게 슬라이딩을 하느냐이다. 
여기서는 move라는 정수를 선언해서 했는데
move = cnt(틀린 위치) - fail[cnt]이다. 
여기서 -1을 해준것은 어차피 i는 한번 지나면서 반복문의 i++때문에 증가할 것이기 때문. 

만약 전부 일치했을 경우에는 마지막 숫자가 틀렸다라는 가정을 하고 이동을 시켜주면 되기대문에 cnt-1 이라고 하고 -2를 해준 것이다. 

flag값이 보일것이다, 이것은 순전히 해당 텍스트가 바이러스를 갖고 있는지를 확인해서 리턴해주는 것을 확인하는 용이다.

BM준비
5.suffix(패턴, 몇개까지의 suffix를 구하고 싶은지 갯수)
이 함수는 앞에서 몇개, 뒤에서 몇개 이렇게 일치하는지 확인 하는 것이다. 
l에는 .length()를 계속 쓸수 없으니, 길이를 선언해준다. 
반복문 첫번째에는, 구하고 싶은 suffix의 문자갯수만큼 돌리고
그 밑에는 우선 패턴의 길이 만큼 반복문을 선언한다. 
check에는 ㅣ - j + i - 1이라고 선언을 했는데, 복잡해 보이지만 사실 뒤에서 몇번째 이라는 것이다. 
예를들어 ASTRACASTRA일경우 만약 a가 3이라면 AST 와 TRA를 비교하는 것이다. 
이대 각각 A =? T, S=? R, T =? A 를 비교 하는 것이다. 사실 첫번째에서 일치하지 않으면 바로 break로 탈출하게 만들어 놨다. 
만약 하나씩 맞다면 suf라는 정수에 i를 넣어준다. (i가 0부터 시작해서 마지막 리턴값에 +1을 해줘야 한다)
만약 a가 전체문자열의 반 이상이면 문자열의 반까지만 체크하고 그 뒤는 체크 하지 않도록 break를 해 놓았다. 
그리고 리턴 값으로  구한 suf에 +1을 더한 값을 해준다. (i 가 0부터 시작해서 실질적인 숫자로 쓰려면 +1 을 해줘야한다)

6.matchjump( 패턴, 패턴을 쪼갠 파트, 몇번째 문자, 원래 패턴) 
먼저 전재하고 갈것은 
갑- P(r-1) != P(k)  m-(r-1)
을- P(r-1) = P(k)  m-k+m-q
인경우이다. 
found는 앞으로 비교할 문자가 몇번재에 있는지를 찾는것이다. 만약에 없으면 디버그시 -1 이 나온것으로 판단. 
save1 save2는 갑의 경우냐, 을의경우냐를 판단하는 것이다. 디버깅할때 -100이 나오는 것으로 여부를 판단한다. 
m은 원래 패턴의 길이 
q는 내가 비교하려는 번째의 접두 접미가 일치하는가? 사실 이것은 위에서 만든 suffix함수로 받아올것이다. 현재의 위치 기준으로 접두 접미는 몇개나 같은지를 확인 저장한다. 

우선 가장 중요한 파트이다. 
matchjump를 찾기 위해서는 현재 내가 i라는 위치에 있다고 가정하면 i의 오른쪽에 있는 만큼의 문자들이 패턴내에 겹치는 위치가 있는 지를 찾는것이다. 
found = pattern.find(part, found+1)이라고 선언 한 것은 문자열 내에서 지속적으로 같은 즉 함수 맨 위에서 가져온 패턴을 쪼갠 파트가 존재하는 지를 왼쪽에서 오른쪽으로 계속 확인하는 것이다. 
이때 조건문으로 써서, 만약 찾았을 경우
갑의 경우인가? 을의 경우인가를 나누어서 각각 그 위치를 save1과 save2에다가 저장했다. 
방금 말한 이 find를 이용하는 것이 matchjump 배열을 짜는 가장 핵심이 되는 파트이다. 

그 뒤에 나오는 조건문은  1 2 3 예외 4 라고 했다. 

1일 경우에는 아무것도 일치하는 것이 없을 경우이다. 
이경우에는 을의 경우를 적용시킨다. 

2일 경우에는 일치하는 패턴 파트를 찾긴 찾았는데 문자가 같아서 을인 경우이다. 
이때 갑의 계산을 해주자.

3일 경우에는 갑의 경우이다. 

특별 예외사항은 찾긴 찾았는데 save1에 저장되는 숫자가 0인 경우이다. 
이때는 보이기에는 갑의 경우처럼 보이지만 을을 적용해 줘야 한다.

4와 같은 경우에는 갑 을 모든 패턴이 다 존재하는 것이다. 하지만
같지 않은 경우를 지향해야 함으로 갑의 게산을 해준다. 

위와같이 계산한 answer을 리턴해서 후에 mjarray에 넣어줄 것이다. 


7.mjarray(패턴, mj배열)
생각보다 간단하다. 말그대로 mj배열에 위에서 matchjump에서 구한 값을 넣어준다고 생각하면 된다. 
일단 반복문으로 바로 들어가서 오른쪽에서 부터 쭉 계산을 할때 몇번째까지 계산을 하고 싶은지를 substr을 이용해서 자른다. 
이것을 matchjumpnum이라는 곳에 matchjump를 이용해서 계산을 해주고 해당 번째를 mj배열에 저장한다. 

8.calbm ( 텍스트, 패턴, mj배열)
필요한 요소들은 모두다 구했다. mj배열도 구했고, 텍스트랑 패턴을 비교하는 중첩 반복문을 작성한다. 
보이어 무어 같은 경우에는 패턴의 오른쪽 부터 왼쪽으로 비교한다는 사실을 잊으면 안된다. 그리고 미스매치가 일어났을 경우에는 바로 탈출해서 슬라이딩을 할 준비를 하고
만약에 똑같다면 cnt를 하나씩 올려준다. 
그 다음 if문에서는 슬라이딩을 할 것이다. 
슬라이딩은 기본적으로 mj[z] - (m - z ) 이다.
우선 전체가 일치할 경우에는 kmp랑 똑같이 가장 마지막이 틀렸다는 가정을 하고 슬라이딩을 할것이다. 
따라서 mj[1] - (m-1)-1 이고
만약 일치하지 않았다면 mj[m-j] - (m - (m-j))-1 이다
각각 위에서 마지막에 -1 을 해주는 것은 반복문을 통해서 어차피 +1이 늘어날 것이기 때문이고 
i가 m-j가 되는 이유는, j=0부터 시작해서 쭉 나아가기 때문에 m에서 빼줘야 우리가 원하는 z값(위에서 말한)이 나온다. 

flag값이 보일것이다, 이것은 순전히 해당 텍스트가 바이러스를 갖고 있는지를 확인해서 리턴해주는 것을 확인하는 용이다.



main함수를 보도록 하자. 
기본적인 것들은 대부분 거의다 위에 함수로 선언을 했다.  
어떤방식으로 텍스트 파일을 불러올지 정도를 정하고 불러온 텍스트는 각각 text[i]에 저장이 된다. 
우리가 선언한 악성코드는 badcode로 저장하고 우리가 지정한 길이의 악성코드 패턴은 codep[i]에 해당 길이 만큼 저장되게 만들었다. 
text[i]에는 텍스트 파일로 불러온 문자열이 쭉 저장되어있고 codep[i]는 우리가 비교하고 싶은 패턴을 해당길이로 자른 것들이 저장되어있다. 

그리고 각각 BM과 KMP를 실행하면 완성이다. 보이어와 kmp에 돌입하기 전 타이머를 시작하고 완전 끝났을때 타이머를 끝낸다.
각각 중첩문을 두번 돌려서 각각 원하는 mjarray나 fail배열을 먼저 선언을 하고 bmmove나 kmpmove하는 식으로 한다. 
그리고 각각 int 함수로 구현을 해서 한 텍스트에서 바이러스를 몇번 찾았는지도 찾아낼수 있지만 제시하신 조건을 충족하기 위하여 그 cnt가 1이상인것을 확인해서 해당 txt에 바이러스가 유무만을 확인했다. 

몇개의 텍스트 파일이 바이러스를 갖고 있는지 혹은 갖고 있지 않은지를 구한다. 
